// Test: constant expressions
int num = 42;
float flt = 3.14;
bool t = true;
bool f = false;

// Test: ID expression
int x = num;

// Test: binary operations - arithmetic
int add = (5 + 3);
int sub = (10 - 4);
int mul = (6 * 7);
int div = (20 / 4);
int mod = (17 % 5);

// Test: arithmetic with floats
float fadd = (5.5 + 3.2);
float fsub = (10.7 - 4.3);
float fmul = (6.1 * 7.2);
float fdiv = (20.5 / 4.1);

// Test: arithmetic chaining
int chain_add = (1 + 2 + 3);
int chain_mul = (2 * 3 * 4);
int chain_mixed = (2 + 3 * 4);
int chain_sub = (100 - 50 - 10);
int chain_div = (100 / 5 / 2);

// Test: binary operations - relational
bool lt = (5 < 10);
bool le = (5 <= 5);
bool gt = (10 > 5);
bool ge = (5 >= 5);
bool eq = (5 == 5);
bool ne = (5 != 3);

// Test: relational with floats
bool flt_eq = (3.14 == 3.14);
bool flt_ne = (2.71 != 3.14);
bool flt_lt = (2.5 < 3.5);
bool flt_ge = (5.0 >= 4.9);

// Test: relational chaining
bool rel_chain1 = ((5 < 10) && (10 < 20));
bool rel_chain2 = ((5 > 3) && (3 > 1));

// Test: binary operations - logical
bool and_test = (true && false);
bool or_test = (true || false);
bool and_true = (true && true);
bool or_false = (false || false);

// Test: logical chaining
bool logical_chain1 = (true && true && true);
bool logical_chain2 = (false || false || true);
bool logical_mixed = ((true && false) || (true && true));

// Test: unary operations - negation
int neg = (-42);
float neg_flt = (-3.14);
int neg_chain = (-(-5));
float neg_chain_flt = (-(-2.5));

// Test: unary operations - logical NOT
bool not_test = (!true);
bool not_false = (!false);
bool not_chain = (!(!(true)));

// Test: unary with expressions
int neg_expr = (-(5 + 3));
bool not_expr = (!(true && false));

// Test: type cast
int cast_int = (int) 3.14;
float cast_flt = (float) 42;
bool cast_bool = (bool) 1;

// Test: cast with expressions
int cast_expr_int = (int) (3.5 + 2.5);
float cast_expr_flt = (float) (42 + 8);

// Test: complex expressions
int complex1 = ((5 + 3) * (10 - 2));
bool complex2 = ((5 < 10) && (3 != 3));
float complex3 = (((1.5 + 2.5) * 2.0) / 2.0);

// Test: deeply nested binops
int deep_nested = (((((1 + 2) + 3) + 4) + 5));
bool deep_logical = ((((true && true) && true) && true));

// Test: mixed arithmetic and relational
bool mixed_arith_rel = ((5 + 3) == 8);
bool mixed_arith_rel2 = ((10 - 2) < 9);

// Test: all arithmetic operators together
int all_arith = ((2 + 3) * (10 - 4) / 2 - 1);

// Test: modulo edge cases
int mod_simple = (17 % 5);
int mod_zero_result = (10 % 5);
int mod_large = (1000 % 7);

// Test: division edge case
int div_integer = (15 / 3);
float div_float = (15.0 / 4.0);

// Test: negation with binary operations
int neg_add = (-(5 + 3));
int neg_mul = (-(6 * 7));
float neg_div = (-(20.0 / 4.0));

// Test: NOT with relational operations
bool not_rel = (!(5 == 5));
bool not_and = (!(true && true));
bool not_or = (!(false || false));

// Test: combinations of unary operators
bool double_not = (!(!true));
int neg_neg = (-(-42));
float neg_neg_flt = (-(-3.14));

// Test: expressions in assignments
int a = 0;
a = (a + 1);
float b = 0.0;
b = (b + 1.5);
bool c = false;
c = (!c);

// Test: expressions in control structures
if ((5 > 3) && (2 < 4)) {
    int in_if = (10 + 20);
}

while ((x > 0)) {
    x = (x - 1);
}

do {
    a = (a + 1);
} while ((a < 5));

for (int i = 0, i < 10, (i + 1)) {
    int loop_expr = (i * 2);
}

// Test: binop and monop in complex control structures
if (((-5) < 0) && (!(false))) {
    int cond = ((-10) + 20);
}

while (((-a) != 0)) {
    a = (-(a - 1));
}